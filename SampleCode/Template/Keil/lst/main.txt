; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.ANALOG_PWM_ConfigOutputChannel||, CODE, READONLY, ALIGN=2

                  ANALOG_PWM_ConfigOutputChannel PROC
;;;44     
;;;45     void ANALOG_PWM_ConfigOutputChannel(uint8_t duty)
000000  4907              LDR      r1,|L1.32|
;;;46     {
;;;47         if(ANALOG_CNT > ANALOG_PWMWIDTH)
000002  2200              MOVS     r2,#0
000004  888b              LDRH     r3,[r1,#4]  ; ANALOG_CNT
000006  2b64              CMP      r3,#0x64
000008  d900              BLS      |L1.12|
;;;48         {
;;;49         	ANALOG_CNT = 0;
00000a  808a              STRH     r2,[r1,#4]
                  |L1.12|
;;;50         }
;;;51     
;;;52         if(ANALOG_CNT <= duty)
00000c  888b              LDRH     r3,[r1,#4]  ; ANALOG_CNT
;;;53         {
;;;54         	PB14 = 1;	//return 1;
00000e  4905              LDR      r1,|L1.36|
000010  4283              CMP      r3,r0                 ;52
000012  d802              BHI      |L1.26|
000014  2001              MOVS     r0,#1
000016  6388              STR      r0,[r1,#0x38]
;;;55         }
;;;56     
;;;57         else     //if((cnt > duty)) && (cnt <= period))
;;;58         {
;;;59         	PB14 = 0;	//return 0;
;;;60         }
;;;61     }
000018  4770              BX       lr
                  |L1.26|
00001a  638a              STR      r2,[r1,#0x38]         ;59
00001c  4770              BX       lr
;;;62     
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      ||.data||
                  |L1.36|
                          DCD      0x40004840

                          AREA ||i.ANALOG_PWM_Init||, CODE, READONLY, ALIGN=2

                  ANALOG_PWM_Init PROC
;;;62     
;;;63     void ANALOG_PWM_Init(void)
000000  b510              PUSH     {r4,lr}
;;;64     {
;;;65         GPIO_SetMode(PB, BIT14, GPIO_MODE_OUTPUT);
000002  2201              MOVS     r2,#1
000004  0391              LSLS     r1,r2,#14
000006  4803              LDR      r0,|L2.20|
000008  f7fffffe          BL       GPIO_SetMode
;;;66     
;;;67     	ANALOG_PWM_TIMER0_Init();
00000c  f7fffffe          BL       ANALOG_PWM_TIMER0_Init
;;;68     	
;;;69     }
000010  bd10              POP      {r4,pc}
;;;70     
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40004040

                          AREA ||i.ANALOG_PWM_TIMER0_Init||, CODE, READONLY, ALIGN=2

                  ANALOG_PWM_TIMER0_Init PROC
;;;35     
;;;36     void ANALOG_PWM_TIMER0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;37     {
;;;38         TIMER_Open(TIMER0, TIMER_PERIODIC_MODE, ANALOG_PWMTIMER);
000002  4c0b              LDR      r4,|L3.48|
000004  2101              MOVS     r1,#1
000006  4a09              LDR      r2,|L3.44|
000008  06c9              LSLS     r1,r1,#27
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       TIMER_Open
000010  6820              LDR      r0,[r4,#0]
000012  2101              MOVS     r1,#1
000014  0749              LSLS     r1,r1,#29
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
00001a  1548              ASRS     r0,r1,#21
00001c  4905              LDR      r1,|L3.52|
00001e  6008              STR      r0,[r1,#0]
000020  6820              LDR      r0,[r4,#0]
000022  0589              LSLS     r1,r1,#22
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;39         TIMER_EnableInt(TIMER0);
;;;40         NVIC_EnableIRQ(TMR0_IRQn);	
;;;41         TIMER_Start(TIMER0);
;;;42     }
000028  bd10              POP      {r4,pc}
;;;43     
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      0x00030d40
                  |L3.48|
                          DCD      0x40050000
                  |L3.52|
                          DCD      0xe000e100

                          AREA ||i.PWM1_CH1_Init||, CODE, READONLY, ALIGN=2

                  PWM1_CH1_Init PROC
;;;70     
;;;71     void PWM1_CH1_Init(void)	//PB14
000000  b510              PUSH     {r4,lr}
;;;72     {
;;;73         PWM_ConfigOutputChannel(PWM1, 1, 20000, LED_REVERSE(0));
000002  4c09              LDR      r4,|L4.40|
000004  2364              MOVS     r3,#0x64
000006  4a07              LDR      r2,|L4.36|
000008  2101              MOVS     r1,#1
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       PWM_ConfigOutputChannel
;;;74         PWM_EnableOutput(PWM1, PWM_CH_1_MASK);
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       PWM_EnableOutput
;;;75     
;;;76         /* Start PWM module */
;;;77         PWM_Start(PWM1, PWM_CH_1_MASK);
000018  2102              MOVS     r1,#2
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       PWM_Start
;;;78     
;;;79     }
000020  bd10              POP      {r4,pc}
;;;80     
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      0x00004e20
                  |L4.40|
                          DCD      0x40059000

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;177    
;;;178    void SYS_Init(void)
000000  b5f8              PUSH     {r3-r7,lr}
000002  2059              MOVS     r0,#0x59
000004  4c1e              LDR      r4,|L5.128|
000006  2216              MOVS     r2,#0x16
000008  2188              MOVS     r1,#0x88
                  |L5.10|
00000a  6020              STR      r0,[r4,#0]
00000c  6022              STR      r2,[r4,#0]
00000e  6021              STR      r1,[r4,#0]
000010  6823              LDR      r3,[r4,#0]
000012  2b00              CMP      r3,#0
000014  d0f9              BEQ      |L5.10|
;;;179    {
;;;180        /* Unlock protected registers */
;;;181        SYS_UnlockReg();
;;;182    
;;;183        /* Enable HIRC clock (Internal RC 48MHz) */
;;;184        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000016  2004              MOVS     r0,#4
000018  f7fffffe          BL       CLK_EnableXtalRC
;;;185    
;;;186        /* Wait for HIRC clock ready */
;;;187        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;188    
;;;189        /* Select HCLK clock source as HIRC and HCLK source divider as 1 */
;;;190        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
000022  2100              MOVS     r1,#0
000024  2007              MOVS     r0,#7
000026  f7fffffe          BL       CLK_SetHCLK
;;;191    
;;;192        /* Enable UART0 clock */
;;;193        CLK_EnableModuleClock(UART0_MODULE);
00002a  4d16              LDR      r5,|L5.132|
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       CLK_EnableModuleClock
;;;194        CLK_EnableModuleClock(TMR3_MODULE);
000032  4e15              LDR      r6,|L5.136|
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       CLK_EnableModuleClock
;;;195    
;;;196    	#if defined (MODULE_PWM)	
;;;197        CLK_EnableModuleClock(PWM1_MODULE);
;;;198    	#endif
;;;199    
;;;200    	#if defined (MODULE_ANALOG_PWM)	
;;;201        CLK_EnableModuleClock(TMR0_MODULE);
00003a  4f14              LDR      r7,|L5.140|
00003c  4638              MOV      r0,r7
00003e  f7fffffe          BL       CLK_EnableModuleClock
;;;202    	#endif
;;;203    	
;;;204    	
;;;205        /* Switch UART0 clock source to HIRC */
;;;206        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_PCLK0, CLK_CLKDIV0_UART0(1));
000042  2200              MOVS     r2,#0
000044  0679              LSLS     r1,r7,#25
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       CLK_SetModuleClock
;;;207        CLK_SetModuleClock(TMR3_MODULE, CLK_CLKSEL1_TMR3SEL_PCLK1, 0);
00004c  2200              MOVS     r2,#0
00004e  0539              LSLS     r1,r7,#20
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       CLK_SetModuleClock
;;;208    
;;;209    	#if defined (MODULE_PWM)
;;;210        CLK_SetModuleClock(PWM1_MODULE, CLK_CLKSEL2_PWM1SEL_PCLK1, 0);
;;;211    	#endif
;;;212    	#if defined (MODULE_ANALOG_PWM)
;;;213        CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_PCLK0, 0);
000056  2101              MOVS     r1,#1
000058  2200              MOVS     r2,#0
00005a  0249              LSLS     r1,r1,#9
00005c  4638              MOV      r0,r7
00005e  f7fffffe          BL       CLK_SetModuleClock
;;;214    	#endif
;;;215    
;;;216    
;;;217        /* Update System Core Clock */
;;;218        SystemCoreClockUpdate();
000062  f7fffffe          BL       SystemCoreClockUpdate
;;;219    
;;;220        /* Set PB multi-function pins for UART0 RXD=PB.12 and TXD=PB.13 */
;;;221        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk))    |       \
000066  06a8              LSLS     r0,r5,#26
000068  6bc1              LDR      r1,[r0,#0x3c]
00006a  22ff              MOVS     r2,#0xff
00006c  0412              LSLS     r2,r2,#16
00006e  4391              BICS     r1,r1,r2
000070  2233              MOVS     r2,#0x33
000072  0452              LSLS     r2,r2,#17
000074  1889              ADDS     r1,r1,r2
000076  63c1              STR      r1,[r0,#0x3c]
000078  2000              MOVS     r0,#0
00007a  6020              STR      r0,[r4,#0]
;;;222                        (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
;;;223    
;;;224    	#if defined (MODULE_PWM)
;;;225        SYS->GPB_MFPH = (SYS->GPB_MFPH & (~SYS_GPB_MFPH_PB14MFP_Msk)) |
;;;226                        SYS_GPB_MFPH_PB14MFP_PWM1_CH1;
;;;227    	#endif
;;;228    
;;;229        /* Lock protected registers */
;;;230        SYS_LockReg();
;;;231    }
00007c  bdf8              POP      {r3-r7,pc}
;;;232    
                          ENDP

00007e  0000              DCW      0x0000
                  |L5.128|
                          DCD      0x40000100
                  |L5.132|
                          DCD      0x5f803d10
                  |L5.136|
                          DCD      0x5f400005
                  |L5.140|
                          DCD      0x5e800002

                          AREA ||i.TIMER3_Init||, CODE, READONLY, ALIGN=2

                  TIMER3_Init PROC
;;;149    
;;;150    void TIMER3_Init(void)
000000  b510              PUSH     {r4,lr}
;;;151    {
;;;152        TIMER_Open(TIMER3, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L6.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  0621              LSLS     r1,r4,#24
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
00001a  1488              ASRS     r0,r1,#18
00001c  4904              LDR      r1,|L6.48|
00001e  6008              STR      r0,[r1,#0]
000020  6820              LDR      r0,[r4,#0]
000022  0589              LSLS     r1,r1,#22
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;153        TIMER_EnableInt(TIMER3);
;;;154        NVIC_EnableIRQ(TMR3_IRQn);	
;;;155        TIMER_Start(TIMER3);
;;;156    }
000028  bd10              POP      {r4,pc}
;;;157    
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x40051020
                  |L6.48|
                          DCD      0xe000e100

                          AREA ||i.TMR0_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR0_IRQHandler PROC
;;;26     
;;;27     void TMR0_IRQHandler(void)
000000  4805              LDR      r0,|L7.24|
000002  6881              LDR      r1,[r0,#8]
000004  07c9              LSLS     r1,r1,#31
000006  0fc9              LSRS     r1,r1,#31
;;;28     {
000008  d005              BEQ      |L7.22|
00000a  2101              MOVS     r1,#1
00000c  6081              STR      r1,[r0,#8]
;;;29         if(TIMER_GetIntFlag(TIMER0) == 1)
;;;30         {
;;;31             TIMER_ClearIntFlag(TIMER0);
;;;32     		ANALOG_CNT++;
00000e  4903              LDR      r1,|L7.28|
000010  8888              LDRH     r0,[r1,#4]  ; ANALOG_CNT
000012  1c40              ADDS     r0,r0,#1
000014  8088              STRH     r0,[r1,#4]
                  |L7.22|
;;;33         }
;;;34     }
000016  4770              BX       lr
;;;35     
                          ENDP

                  |L7.24|
                          DCD      0x40050000
                  |L7.28|
                          DCD      ||.data||

                          AREA ||i.TMR3_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  TMR3_IRQHandler PROC
;;;80     
;;;81     void TMR3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
000002  4919              LDR      r1,|L8.104|
000004  6888              LDR      r0,[r1,#8]
000006  07c0              LSLS     r0,r0,#31
000008  0fc0              LSRS     r0,r0,#31
;;;82     {
00000a  d02c              BEQ      |L8.102|
00000c  2301              MOVS     r3,#1
00000e  608b              STR      r3,[r1,#8]
;;;83     	static uint32_t LOG = 0;
;;;84     	static uint16_t CNT = 0;
;;;85     
;;;86         if(TIMER_GetIntFlag(TIMER3) == 1)
;;;87         {
;;;88             TIMER_ClearIntFlag(TIMER3);
;;;89     
;;;90     		#if defined (MODULE_PWM)
;;;91     		if (CNT_LED++ >= 18)
;;;92     		{		
;;;93     			CNT_LED = 0;
;;;94     			PWM_ConfigOutputChannel(PWM1, 1, 20000, LED_REVERSE(DUTY_LED));
;;;95     //			printf("DUTY : %4d\r\n" ,DUTY_LED );
;;;96     			if (FLAG_LED)
;;;97     			{
;;;98     				if ( ++DUTY_LED == 100)
;;;99     				{
;;;100    					FLAG_LED = 0;
;;;101    					DUTY_LED = 100;
;;;102    				}
;;;103    			}
;;;104    			else
;;;105    			{
;;;106    				if ( --DUTY_LED == 0)
;;;107    				{
;;;108    					FLAG_LED = 1;
;;;109    					DUTY_LED = 0;
;;;110    				}			
;;;111    			}
;;;112    		}
;;;113    		#endif
;;;114    
;;;115    		#if defined (MODULE_ANALOG_PWM)
;;;116    		if (CNT_LED++ >= 18)
000010  4916              LDR      r1,|L8.108|
000012  7888              LDRB     r0,[r1,#2]  ; CNT_LED
000014  1c42              ADDS     r2,r0,#1
000016  708a              STRB     r2,[r1,#2]
000018  2200              MOVS     r2,#0
00001a  2812              CMP      r0,#0x12
00001c  d314              BCC      |L8.72|
;;;117    		{		
;;;118    			CNT_LED = 0;
00001e  708a              STRB     r2,[r1,#2]
;;;119    //			printf("DUTY : %4d\r\n" ,DUTY_LED );	
;;;120    			if (FLAG_LED)
000020  784c              LDRB     r4,[r1,#1]  ; FLAG_LED
000022  4608              MOV      r0,r1                 ;116
;;;121    			{
;;;122    				if ( ++DUTY_LED == 100)
000024  7800              LDRB     r0,[r0,#0]
000026  2c00              CMP      r4,#0                 ;120
000028  d007              BEQ      |L8.58|
00002a  1c40              ADDS     r0,r0,#1              ;120
00002c  b2c0              UXTB     r0,r0
00002e  7008              STRB     r0,[r1,#0]
000030  2864              CMP      r0,#0x64
000032  d109              BNE      |L8.72|
;;;123    				{
;;;124    					FLAG_LED = 0;
000034  704a              STRB     r2,[r1,#1]
;;;125    					DUTY_LED = 100;
000036  7008              STRB     r0,[r1,#0]
000038  e006              B        |L8.72|
                  |L8.58|
00003a  1e40              SUBS     r0,r0,#1
;;;126    				}
;;;127    			}
;;;128    			else
;;;129    			{
;;;130    				if ( --DUTY_LED == 0)
00003c  0600              LSLS     r0,r0,#24
00003e  0e00              LSRS     r0,r0,#24
000040  7008              STRB     r0,[r1,#0]
000042  d101              BNE      |L8.72|
;;;131    				{
;;;132    					FLAG_LED = 1;
000044  704b              STRB     r3,[r1,#1]
;;;133    					DUTY_LED = 0;
000046  700a              STRB     r2,[r1,#0]
                  |L8.72|
;;;134    				}			
;;;135    			}
;;;136    		}
;;;137    		#endif
;;;138    
;;;139    		
;;;140    	
;;;141    		if (CNT++ >= 1000)
000048  88c8              LDRH     r0,[r1,#6]  ; CNT
00004a  1c43              ADDS     r3,r0,#1
00004c  80cb              STRH     r3,[r1,#6]
00004e  237d              MOVS     r3,#0x7d
000050  00db              LSLS     r3,r3,#3
000052  4298              CMP      r0,r3
000054  d307              BCC      |L8.102|
;;;142    		{		
;;;143    			CNT = 0;
000056  80ca              STRH     r2,[r1,#6]
;;;144            	printf("%s : %4d\r\n",__FUNCTION__,LOG++);
000058  688a              LDR      r2,[r1,#8]  ; LOG
00005a  1c50              ADDS     r0,r2,#1
00005c  6088              STR      r0,[r1,#8]  ; LOG
00005e  4904              LDR      r1,|L8.112|
000060  a004              ADR      r0,|L8.116|
000062  f7fffffe          BL       __2printf
                  |L8.102|
;;;145    		}
;;;146        }
;;;147    }
000066  bd10              POP      {r4,pc}
;;;148    
                          ENDP

                  |L8.104|
                          DCD      0x40051020
                  |L8.108|
                          DCD      ||.data||
                  |L8.112|
                          DCD      ||.constdata||
                  |L8.116|
000074  2573203a          DCB      "%s : %4d\r\n",0
000078  20253464
00007c  0d0a00  
00007f  00                DCB      0

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;158    
;;;159    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;160    {
;;;161    
;;;162        SYS_ResetModule(UART0_RST);
000002  4816              LDR      r0,|L9.92|
000004  f7fffffe          BL       SYS_ResetModule
;;;163    
;;;164        /* Configure UART0 and set UART0 baud rate */
;;;165        UART_Open(UART0, 115200);
000008  4c15              LDR      r4,|L9.96|
00000a  21e1              MOVS     r1,#0xe1
00000c  0249              LSLS     r1,r1,#9
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;166    
;;;167    	/* Set UART receive time-out */
;;;168    	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;169    
;;;170    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00001c  f7fffffe          BL       CLK_GetCPUFreq
000020  4601              MOV      r1,r0
000022  a010              ADR      r0,|L9.100|
000024  f7fffffe          BL       __2printf
;;;171    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000028  f7fffffe          BL       CLK_GetHXTFreq
00002c  4601              MOV      r1,r0
00002e  a014              ADR      r0,|L9.128|
000030  f7fffffe          BL       __2printf
;;;172    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000034  f7fffffe          BL       CLK_GetLXTFreq
000038  4601              MOV      r1,r0
00003a  a017              ADR      r0,|L9.152|
00003c  f7fffffe          BL       __2printf
;;;173    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000040  f7fffffe          BL       CLK_GetPCLK0Freq
000044  4601              MOV      r1,r0
000046  a01a              ADR      r0,|L9.176|
000048  f7fffffe          BL       __2printf
;;;174    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
00004c  f7fffffe          BL       CLK_GetPCLK1Freq
000050  4601              MOV      r1,r0
000052  a01e              ADR      r0,|L9.204|
000054  f7fffffe          BL       __2printf
;;;175    	
;;;176    }
000058  bd10              POP      {r4,pc}
;;;177    
                          ENDP

00005a  0000              DCW      0x0000
                  |L9.92|
                          DCD      0x04000010
                  |L9.96|
                          DCD      0x40070000
                  |L9.100|
000064  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000068  4b5f4765
00006c  74435055
000070  46726571
000074  203a2025
000078  38640d0a
00007c  00      
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0
                  |L9.128|
000080  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
000084  47657448
000088  58544672
00008c  6571203a
000090  20253864
000094  0d0a00  
000097  00                DCB      0
                  |L9.152|
000098  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
00009c  4765744c
0000a0  58544672
0000a4  6571203a
0000a8  20253864
0000ac  0d0a00  
0000af  00                DCB      0
                  |L9.176|
0000b0  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000b4  47657450
0000b8  434c4b30
0000bc  46726571
0000c0  203a2025
0000c4  38640d0a
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L9.204|
0000cc  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000d0  47657450
0000d4  434c4b31
0000d8  46726571
0000dc  203a2025
0000e0  38640d0a
0000e4  00      
0000e5  00                DCB      0
0000e6  00                DCB      0
0000e7  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;240    
;;;241    int main()
000000  f7fffffe          BL       SYS_Init
;;;242    {
;;;243        SYS_Init();
;;;244    
;;;245        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;246    
;;;247    	TIMER3_Init();
000008  f7fffffe          BL       TIMER3_Init
;;;248    
;;;249    	#if defined (MODULE_PWM)
;;;250    	PWM1_CH1_Init();
;;;251    	#endif
;;;252    	#if defined (MODULE_ANALOG_PWM)
;;;253    	ANALOG_PWM_Init();
00000c  f7fffffe          BL       ANALOG_PWM_Init
;;;254    
;;;255    	#endif
;;;256    	
;;;257        /* Got no where to go, just loop forever */
;;;258        while(1)
;;;259        {
;;;260    		#if defined (MODULE_ANALOG_PWM)
;;;261    		ANALOG_PWM_ConfigOutputChannel(LED_REVERSE(DUTY_LED));
000010  4d03              LDR      r5,|L10.32|
000012  2464              MOVS     r4,#0x64
                  |L10.20|
000014  7828              LDRB     r0,[r5,#0]  ; DUTY_LED
000016  1a20              SUBS     r0,r4,r0
000018  b2c0              UXTB     r0,r0
00001a  f7fffffe          BL       ANALOG_PWM_ConfigOutputChannel
00001e  e7f9              B        |L10.20|
;;;262    		#endif
;;;263        }
;;;264    }
;;;265    
                          ENDP

                  |L10.32|
                          DCD      ||.data||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  544d5233          DCB      0x54,0x4d,0x52,0x33
000004  5f495251          DCB      0x5f,0x49,0x52,0x51
000008  48616e64          DCB      0x48,0x61,0x6e,0x64
00000c  6c657200          DCB      0x6c,0x65,0x72,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  DUTY_LED
000000  00                DCB      0x00
                  FLAG_LED
000001  01                DCB      0x01
                  CNT_LED
000002  0000              DCB      0x00,0x00
                  ANALOG_CNT
000004  0000              DCW      0x0000
                  ||CNT||
000006  0000              DCW      0x0000
                  LOG
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_15ade6e8____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_15ade6e8____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_15ade6e8____REVSH|
#line 402
|__asm___6_main_c_15ade6e8____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
